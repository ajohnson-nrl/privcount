# Deployment

First, make sure you have downloaded and installed the latest version of
PrivCount. If you are running a data collector, also download, compile,
install, and launch the latest version of the Tor PrivCount patch.

See INSTALL.markdown for details.

## Tally Server

### Configuration

#### Listen Address

Choose an IP address and port that is accessible on the Internet.

Add the following lines to the tally server config.yaml:

tally_server:
    listen_port: port

Send the following lines to the Share Keepers and Data Collectors for their
config.yaml:

share_keeper:
    tally_server_info:
        ip: 'IP address'
        port: port

data_collector:
    tally_server_info:
        ip: 'IP address'
        port: port

#### Counter Configuration

Ask the Data Collectors for their relay fingerprints. Some noise weight schemes
also need to know which physical machine each fingerprint is located on.

Configure the counters for this round, and the noise amounts for those
counters:

tally_server:
    counters: 'counters.bins.yaml'
    noise: 'counters.noise.yaml'
    noise_weight:
        'FACADE0000000000000000000123456789ABCDEF': 1.0
        '3DEADBEEF012345678900000000000000DEADC00': 1.0

If you want to collect a traffic model, configure it as well:

tally_server:
    traffic_model: 'traffic.model.json'
    traffic_noise: 'traffic.noise.yaml'

#### Collection Configuration

Configure the start thresholds and collection period (in seconds):

tally_server:
    sk_threshold: 5
    dc_threshold: 2
    collect_period: 604800
    delay_period: 86400

The delay period is the number of seconds of user activity that is protected
between rounds where the noise allocation changes. If you are using a custom
delay period, send it to the Share Keepers and Data Collectors.

See doc/CounterChecks.markdown for more details.

### First Run

After configuring the Tally Server, run PrivCount in tally server mode so that
it generates keys:

    screen
    source venv/bin/activate
    privcount ts config.yaml 2>&1 | tee -a ts.log

### Autogenerated Keys

You MUST NOT use test keys for deployment: generate new keys for each network.

On first run, PrivCount creates the keys that it needs to run:

The TallyServer creates a RSA key pair for SSL encryption:
    * no configuration is required: clients do not check this key.

The TallyServer creates a PrivCount secret handshake key:
    * each ShareKeeper and DataCollector needs to know this key to
      successfully handshake with the TallyServer.
    * this is a symmetric key: it MUST be encrypted in transit to Share Keepers
      and Data Collectors.
    * encrypt, sign, and send the file privcount.secret_handshake.yaml to each
      Share Keeper and Data Collector.

See doc/PrivCountAuthentication.markdown for more details.

## Share Keepers

### Configuration

#### Tally Server Address

Add the following Tally Server details to the config.yaml:

share_keeper:
    tally_server_info:
        ip: 'IP address'
        port: port

#### Key Configuration

Place the privcount.secret_handshake.yaml file from the Tally Server in the
Share Keeper's working directory.

See doc/PrivCountAuthentication.markdown for more details.

#### Collection Configuration

share_keeper:
    delay_period: 86400

The delay period is the number of seconds of user activity that is protected
between rounds where the noise allocation changes. If you are using a custom
delay period, it should be the same as the Tally Server's.

See doc/CounterChecks.markdown for more details.

### First Run

Run PrivCount in share keeper mode so that it generates keys:

    screen
    source venv/bin/activate
    privcount sk config.yaml 2>&1 | tee -a sk.log

### Autogenerated Keys

You MUST NOT use test keys for deployment: generate new keys for each network.

On first run, PrivCount creates the keys that it needs to run:

Each ShareKeeper creates a RSA key pair for public key encryption:
    * each DataCollector needs to know the SHA256 hash of the public key of
       each ShareKeeper.
    * to find the fingerprints, read the Share Keeper logs, or use:
    openssl rsa -pubout < keys/sk.pem | openssl dgst -sha256 | cut -d" " -f2
    * sign and send the fingerprint to each Data Collector.

See doc/PrivCountAuthentication.markdown for more details.

## Data Collectors

### Configuration

#### Name

PrivCount uses the name supplied by each node to uniquely identify it.
Each Data Collector must be configured with a unique 'name:' in config.yaml.
(Share Keepers use their public key hash as their name, so it is automatically
unique.)

Node names that are longer than 20 characters will be abbreviated in most
Tally Server log messages.

Configure each data collector with a unique name:

data_collector:
    name: 'MyRelayNickname'

#### Tally Server Address

Add the following Tally Server details to the config.yaml:

data_collector:
    tally_server_info:
        ip: 'IP address'
        port: port

#### Tor Control Port

PrivCount securely authenticates to tor's control port. This prevents the
control port being used to run commands as the tor user.

You can either configure a unix socket or a TCP port:

Unix Socket (more secure):

torrc:

ControlPort 'unix:/var/run/tor/control'

data_collector:
    event_source:
        unix: '/var/run/tor/control'

TCP Port:

torrc:
ControlPort 20003

data_collector:
    event_source:
        port: 20003

Cookie authentication requires the PrivCount user to have read access to tor's
cookie file.Password authentication requires a shared secret configured using
the event_source's control_password option.

Cookie Authentication (more secure, simpler):

CookieAuthentication 1

Password Authentication:

cat /dev/random | hexdump -e '"%x"' -n 32 -v > control_password.txt
tor --hash-password `cat control_password.txt`

torrc:
HashedControlPassword (output of tor --hash-password)

data_collector:
    event_source:
        control_password: 'control_password.txt'

PrivCount doesn't give good diagnostics when Control Port connections fail.
This appears to be an unavoidable consequence of using an outdated connection
API. See issue #303 for more details.

As a workaround, PrivCount will log warnings on both the data collector and
tally server when:
* the control port connection has not been successfully completed, and
* the aggregator stops receiving events for a long period of time.

For more details and troubleshooting steps, see
doc/TorControlAuthentication.markdown.

#### Key Configuration

Place the privcount.secret_handshake.yaml file from the Tally Server in the
Data Collector's working directory.

Add the Share Keepers' public key fingerprints to the config:

data_collector:
    share_keepers:
        - '0e193e4a66cf0332bc64ad613bb651579a10e08afdbb54aa49e9ea2286ccd41c'
        - '3f0f909d1c9b4aaa69e305404b916928f076ee9ea7940a4549550feb3276f676'

See doc/PrivCountAuthentication.markdown for more details.

#### Collection Configuration

data_collector:
    delay_period: 86400

The delay period is the number of seconds of user activity that is protected
between rounds where the noise allocation changes. If you are using a custom
delay period, it should be the same as the Tally Server's.

See doc/CounterChecks.markdown for more details.

### First Run

Then run PrivCount in data collector mode:

    screen
    source venv/bin/activate
    privcount dc config.yaml 2>&1 | tee -a dc.log

When a threshold of data collectors are alive, the tally server will start
collection.
